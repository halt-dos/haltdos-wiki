/*! For license information please see 7fc76826.412721b1.js.LICENSE.txt */
"use strict";(self.webpackChunkhaltdos_wiki=self.webpackChunkhaltdos_wiki||[]).push([[41204],{16024:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>d,contentTitle:()=>h,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"cloud/waf/listener/monitors","title":"Monitors","description":"Continually test your upstream servers, avoid the servers that have failed, and gracefully add the recovered servers into the server group.","source":"@site/versioned_docs/version-7.0/cloud/waf/listener/monitors.md","sourceDirName":"cloud/waf/listener","slug":"/cloud/waf/listener/monitors","permalink":"/v7/cloud/waf/listener/monitors","draft":false,"unlisted":false,"tags":[],"version":"7.0","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"cloud_sidebar","previous":{"title":"Load Balancing","permalink":"/v7/cloud/waf/listener/server-groups/load-balancing"},"next":{"title":"Advanced Settings","permalink":"/v7/cloud/waf/listener/advanced-settings/"}}');var n=t(74848),i=t(28453);const o={sidebar_position:7},h="Monitors",d={},l=[{value:"Overview",id:"overview",level:2},{value:"How to Use:",id:"how-to-use",level:3},{value:"Description",id:"description",level:4}];function a(e){const r={h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"monitors",children:"Monitors"})}),"\n",(0,n.jsx)(r.p,{children:"Continually test your upstream servers, avoid the servers that have failed, and gracefully add the recovered servers into the server group."}),"\n",(0,n.jsx)(r.hr,{}),"\n",(0,n.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(r.p,{children:"Monitoring provides a comprehensive overview of the status and performance of the server group and/or individual servers inside the server group. If a monitor is attached to a server group, then it will get applied to all the servers inside that group automatically. If a monitor is attached to a particular server then it will override the configuration of the server-group monitor. Health Checks computes an overall health state for each upstream server in the listener. Backend(upstream) that responds successfully for the configured number of times is considered healthy. Backend(upstream) that fails to respond successfully for a separate number of times is unhealthy."}),"\n",(0,n.jsx)(r.h3,{id:"how-to-use",children:"How to Use:"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:["Go to ",(0,n.jsx)(r.strong,{children:"WAF > Zones > Listeners > Monitors"})]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:["Click on ",(0,n.jsx)(r.strong,{children:"Add Monitor"})]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:["Click on the monitor name to configure the Health check and click ",(0,n.jsx)(r.strong,{children:"Save Changes"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:["Now go to ",(0,n.jsx)(r.strong,{children:"WAF > Zones > Listeners > Server Groups"})]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsx)(r.p,{children:"Add the monitor to the server group and/or server as required."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"PARAMETERS"}),(0,n.jsx)(r.th,{children:"ACCEPTED VALUES"}),(0,n.jsx)(r.th,{children:"DEFAULT"})]})}),(0,n.jsxs)(r.tbody,{children:[(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"Enable Health Check"}),(0,n.jsx)(r.td,{children:"Enabled/Disabled"}),(0,n.jsx)(r.td,{children:"Disabled"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"Health Check Interval"}),(0,n.jsx)(r.td,{children:"Enabled/Disabled"}),(0,n.jsx)(r.td,{children:"5000"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"Health Check Type"}),(0,n.jsx)(r.td,{children:"TCP/HTTP/SSL Hello/HTTPS"}),(0,n.jsx)(r.td,{children:"TCP"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"Port"}),(0,n.jsx)(r.td,{children:"Port number"}),(0,n.jsx)(r.td,{children:"80"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"Check URI"}),(0,n.jsx)(r.td,{children:"URI"}),(0,n.jsx)(r.td,{children:"GET /"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"Match Status"}),(0,n.jsx)(r.td,{children:"Response Code"}),(0,n.jsx)(r.td,{children:"200"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"Match Content"}),(0,n.jsx)(r.td,{children:"Content to be matched in header/body"}),(0,n.jsx)(r.td,{children:"Blank"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"Fail Threshold"}),(0,n.jsx)(r.td,{children:"Integer"}),(0,n.jsx)(r.td,{children:"1"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"Pass Threshold"}),(0,n.jsx)(r.td,{children:"Integer"}),(0,n.jsx)(r.td,{children:"1"})]})]})]}),"\n",(0,n.jsx)(r.h4,{id:"description",children:"Description"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Enable Health Check"}),": Enable to periodically check the health of upstream servers by sending special health\u2011check requests to each server and verifying the correct response."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Health Check Interval"}),": Set the seconds, say 10, then every 10 seconds WAF sends a request for \u201c/\u201d to each server/server group. If any communication error or timeout occurs (the server responds with a status code other than the expected code) the health check fails. The server is marked as unhealthy, and WAF does not send client requests to it (if attached to server group) until it once again passes a health check."]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Health Check Type:"})}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"HTTP"}),": Works for HTTP servers. Health check sends the request, if unable to send request, then we make that server unhealthy."]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"SSL HELLO"}),": Works for HTTP servers. Health check tries SSL handshake with the server, if failed to do SSL handshake then we make that server as unhealthy."]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"TCP"}),": Works for TCP servers. Health check simply attempts to open a TCP connection to the server on the specified port (which are specified in the configuration file)."]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"HTTPS"}),": Works for HTTPS servers. Health check sends the request, if unable to send request, then we make that server as unhealthy"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Port"}),": Specify a new port with the port parameter"]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Check URI"}),": The specified URI is appended to the server domain name or IP address set for the server in the server block."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Match Status"}),": Using this directive it is possible to verify whether the status is in a specified range. It contains one status code."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Match Content"}),": Using this directive it is possible to verify whether the header or body matches a regular expression. It can contain one status code, one body condition, and multiple header conditions."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Fail Threshold"}),": Sets the number of failed attempts that must occur during the heath check interval period for the server to be marked unavailable (default is 1 attempt)."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Pass Threshold"}),": Sets the number of passes that must occur during the heath check interval period for the server to be marked available (default is 1 attempt). If set as 2, then the server must pass two consecutive checks to be marked as healthy again instead of the default one."]})]})}function c(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},21020:(e,r,t)=>{var s=t(96540),n=Symbol.for("react.element"),i=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,h=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,d={key:!0,ref:!0,__self:!0,__source:!0};function l(e,r,t){var s,i={},l=null,a=null;for(s in void 0!==t&&(l=""+t),void 0!==r.key&&(l=""+r.key),void 0!==r.ref&&(a=r.ref),r)o.call(r,s)&&!d.hasOwnProperty(s)&&(i[s]=r[s]);if(e&&e.defaultProps)for(s in r=e.defaultProps)void 0===i[s]&&(i[s]=r[s]);return{$$typeof:n,type:e,key:l,ref:a,props:i,_owner:h.current}}r.Fragment=i,r.jsx=l,r.jsxs=l},74848:(e,r,t)=>{e.exports=t(21020)},28453:(e,r,t)=>{t.d(r,{R:()=>o,x:()=>h});var s=t(96540);const n={},i=s.createContext(n);function o(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function h(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);